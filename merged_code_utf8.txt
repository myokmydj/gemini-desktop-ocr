// File: package.json

{
  "name": "gemini-desktop-ocr",
  "version": "0.1.0",
  "private": true,
  "main": "public/electron.js",
  "homepage": "./",
  "dependencies": {
    "@google/genai": "^0.14.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "electron-start": "electron .",
    "dev": "concurrently \"cross-env BROWSER=none npm start\" \"wait-on http://localhost:3000 && cross-env ELECTRON_START_URL=http://localhost:3000 npm run electron-start\""
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "cross-env": "^7.0.3",
    "electron": "^31.0.2",
    "font-list": "^2.0.1",
    "wait-on": "^7.2.0"
  }
}


// ======================================================
// File: src\App.css
// ======================================================

/* --- Web Fonts Import --- */
@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-4Regular.woff2') format('woff2');
    font-weight: 400;
    font-display: swap;
}
@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-7Bold.woff2') format('woff2');
    font-weight: 700;
    font-display: swap;
}
@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-4Regular.woff2') format('woff2');
    font-weight: 400;
    font-display: swap;
}
@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-7Bold.woff2') format('woff2');
    font-weight: 700;
    font-display: swap;
}


/* --- Global Styles & Theme --- */
body {
  background-color: #121212;
  background-image: 
    linear-gradient(rgba(255, 255, 255, 0.07) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255, 255, 255, 0.07) 1px, transparent 1px);
  background-size: 20px 20px;
  color: #e0e0e0;
  /* ▼▼▼ [수정] 폰트를 CSS 변수로 관리합니다. ▼▼▼ */
  font-family: var(--global-font-family, 'Paperozi', sans-serif);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 40px 20px;
  min-height: 100vh;
  box-sizing: border-box;
}

/* ... (이하 나머지 CSS 코드는 변경 없음) ... */

/* --- Main App Container --- */
.App {
  background-color: #ffffff;
  color: #000000;
  border: 1px solid #e0e0e0;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  padding: 24px;
  width: 100%;
  max-width: 480px; /* Compact width */
  box-sizing: border-box;
}

h1 {
  font-size: 1.2em;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 4px;
  margin: 0 0 24px 0;
  padding-bottom: 10px;
  border-bottom: 1px solid #e0e0e0;
  font-weight: 700;
}

/* --- Controls Panel (Inspired by Reference 1) --- */
.controls-panel {
  border: 1px solid #e0e0e0;
  padding: 16px;
  margin-bottom: 24px;
}

.control-group {
  margin-bottom: 20px;
}

.control-group:last-child {
  margin-bottom: 0;
}

label {
  display: block;
  font-size: 0.7em;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: #888;
  margin-bottom: 8px;
}

input[type="password"],
select {
  width: 100%;
  background-color: transparent;
  border: none;
  border-bottom: 1px solid #000;
  padding: 8px 0;
  font-family: inherit;
  font-size: 0.9em;
  box-sizing: border-box;
  border-radius: 0;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

select {
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right 5px top 50%;
  background-size: .65em auto;
  padding-right: 20px;
}

button {
  background-color: #000000;
  color: #ffffff;
  border: 1px solid #000000;
  padding: 12px 15px;
  width: 100%;
  font-family: inherit;
  font-size: 0.8em;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

button:hover {
  background-color: #ffffff;
  color: #000000;
}

/* --- Result Panel (Inspired by Reference 2) --- */
.result-panel {
  margin-top: 24px;
}

.result-title {
  background-color: #000;
  color: #fff;
  padding: 6px 12px;
  font-size: 0.8em;
  font-weight: 700;
  letter-spacing: 1px;
  display: inline-block;
  margin-bottom: 0;
}

.result-box {
  border: 1px solid #000;
  padding: 16px;
  min-height: 100px;
  font-size: 0.9em;
  line-height: 1.6;
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* --- Status Messages --- */
.loading, .error {
  text-align: center;
  font-size: 0.8em;
  padding: 15px;
  margin-top: 20px;
  border: 1px solid #e0e0e0;
}

.error {
  border-color: #000;
  color: #000;
  background-color: #f0f0f0;
}


// ======================================================
// File: src\App.js
// ======================================================

import React, { useState, useRef, useEffect } from 'react';
import { GoogleGenAI } from '@google/genai';
import './App.css';

// --- ▼▼▼ [추가] 폰트 관련 상수 및 헬퍼 함수 ---
const API_KEY_STORAGE_KEY = 'gemini-api-key';
const FONT_STORAGE_KEY = 'gemini-ocr-font';

const WEB_FONTS = [
  { name: '페이퍼로지', value: "'Paperozi', sans-serif" },
  { name: '프리젠테이션', value: "'Presentation', sans-serif" },
  { name: '시스템 기본', value: "sans-serif" },
];

// 로컬 스토리지에서 값을 안전하게 불러오는 함수
const getInitialState = (key, defaultValue) => {
  try {
    const savedItem = localStorage.getItem(key);
    return savedItem ? JSON.parse(savedItem) : defaultValue;
  } catch (error) {
    console.error(`Error reading localStorage key “${key}”:`, error);
    return defaultValue;
  }
};

function App() {
  const [apiKey, setApiKey] = useState('');
  const [translatedText, setTranslatedText] = useState('');
  const [targetLanguage, setTargetLanguage] = useState('Korean');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  // --- ▼▼▼ [추가] 폰트 관련 상태 ---
  const [availableFonts, setAvailableFonts] = useState({ web: WEB_FONTS, system: [] });
  const [selectedFont, setSelectedFont] = useState(() => getInitialState(FONT_STORAGE_KEY, WEB_FONTS[0].value));

  const canvasRef = useRef(null);
  const apiKeyRef = useRef(apiKey);

  useEffect(() => {
    apiKeyRef.current = apiKey;
  }, [apiKey]);

  // --- ▼▼▼ [수정] API 키 로딩 로직을 헬퍼 함수 사용으로 변경 ---
  useEffect(() => {
    const storedEncodedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
    if (storedEncodedKey) {
      try {
        const decodedKey = atob(storedEncodedKey);
        setApiKey(decodedKey);
      } catch (e) {
        console.error("Failed to decode API key from storage.", e);
        localStorage.removeItem(API_KEY_STORAGE_KEY);
      }
    }
  }, []);

  useEffect(() => {
    try {
      if (apiKey) {
        const encodedKey = btoa(apiKey);
        localStorage.setItem(API_KEY_STORAGE_KEY, encodedKey);
      } else {
        localStorage.removeItem(API_KEY_STORAGE_KEY);
      }
    } catch (e) {
      console.error("Failed to save API key to storage.", e);
    }
  }, [apiKey]);

  // --- ▼▼▼ [추가] 폰트 관련 useEffect 훅들 ---

  // 1. 앱 시작 시 시스템 폰트 목록을 불러옵니다.
  useEffect(() => {
    const loadSystemFonts = async () => {
      if (window.electronAPI && typeof window.electronAPI.getSystemFonts === 'function') {
        try {
          const systemFonts = await window.electronAPI.getSystemFonts();
          setAvailableFonts(prev => ({ ...prev, system: systemFonts }));
        } catch (error) {
          console.error('Failed to load system fonts:', error);
        }
      }
    };
    loadSystemFonts();
  }, []);

  // 2. 선택된 폰트가 바뀔 때마다 로컬 스토리지에 저장하고,
  //    CSS 변수를 업데이트하여 앱 전체에 즉시 적용합니다.
  useEffect(() => {
    localStorage.setItem(FONT_STORAGE_KEY, JSON.stringify(selectedFont));
    document.documentElement.style.setProperty('--global-font-family', selectedFont);
  }, [selectedFont]);


  // --- 기존 로직 (변경 없음) ---

  useEffect(() => {
    if (window.electronAPI) {
      const handleCaptureComplete = (screenshotDataUrl, rect) => {
        if (screenshotDataUrl && rect && rect.width > 0 && rect.height > 0) {
          processAndTranslate(screenshotDataUrl, rect);
        }
      };
      
      const cleanupListener = window.electronAPI.on('capture-complete', handleCaptureComplete);

      return () => {
        cleanupListener();
      };
    }
  }, []);

  const handleStartCapture = () => {
    if (window.electronAPI) {
      setTranslatedText('');
      setError('');
      window.electronAPI.send('start-capture');
    } else {
      setError("This feature is only available in the Electron app.");
    }
  };

  const processAndTranslate = (dataUrl, selection) => {
    if (!apiKeyRef.current) {
      setError('Please enter your Gemini API Key.');
      return;
    }

    setLoading(true);
    setError('');
    setTranslatedText('');

    const img = new Image();
    img.onload = async () => {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');

      canvas.width = selection.width;
      canvas.height = selection.height;

      ctx.drawImage(img, selection.x, selection.y, selection.width, selection.height, 0, 0, selection.width, selection.height);

      const croppedImageBase64 = canvas.toDataURL('image/png').split(',')[1];

      if (!croppedImageBase64) {
        setError('Failed to crop the selected region.');
        setLoading(false);
        return;
      }

      try {
        const ai = new GoogleGenAI({ apiKey: apiKeyRef.current });
        const imagePart = {
          inlineData: { data: croppedImageBase64, mimeType: 'image/png' },
        };
        const prompt = `Extract text from this image and translate it to ${targetLanguage}. Only provide the translated text.`;

        const response = await ai.models.generateContent({
          model: "gemini-2.5-flash",
          contents: [{ role: "user", parts: [imagePart, { text: prompt }] }],
          config: {
            safetySettings: [
              { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
              { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
            ],
            thinkingConfig: { thinkingBudget: 0 },
          },
        });
        setTranslatedText(response.text);
      } catch (err) {
        console.error(err);
        setError(`An error occurred: ${err.message}`);
      } finally {
        setLoading(false);
      }
    };
    
    img.onerror = () => {
        setError("Failed to load screenshot data.");
        setLoading(false);
    }

    img.src = dataUrl;
  };

  return (
    <div className="App">
      <h1>OCR TRANSLATOR</h1>

      <div className="controls-panel">
        <div className="control-group">
          <label htmlFor="api-key">Gemini API Key</label>
          <input
            id="api-key"
            type="password"
            value={apiKey}
            onChange={(e) => setApiKey(e.target.value)}
            placeholder="Enter and save your key..."
          />
        </div>
        
        {/* --- ▼▼▼ [추가] 폰트 선택 UI --- */}
        <div className="control-group">
          <label htmlFor="font-select">Font</label>
          <select id="font-select" value={selectedFont} onChange={(e) => setSelectedFont(e.target.value)}>
            <optgroup label="Web Fonts">
              {availableFonts.web.map(font => (
                <option key={font.name} value={font.value}>{font.name}</option>
              ))}
            </optgroup>
            {availableFonts.system.length > 0 && (
              <optgroup label="System Fonts">
                {availableFonts.system.map(font => (
                  <option key={font} value={font}>{font}</option>
                ))}
              </optgroup>
            )}
          </select>
        </div>

        <div className="control-group">
          <label htmlFor="language-select">Translate to</label>
          <select
            id="language-select"
            value={targetLanguage}
            onChange={(e) => setTargetLanguage(e.target.value)}
          >
            <option value="Korean">Korean</option>
            <option value="English">English</option>
            <option value="Japanese">Japanese</option>
            <option value="Chinese">Chinese</option>
            <option value="Spanish">Spanish</option>
            <option value="French">French</option>
            <option value="German">German</option>
          </select>
        </div>
        <div className="control-group">
           <button onClick={handleStartCapture}>
            Capture Screen Area
          </button>
        </div>
      </div>
      
      <canvas ref={canvasRef} style={{ display: 'none' }} />

      {error && <div className="error">{error}</div>}
      {loading && <div className="loading">Processing...</div>}
      
      {(translatedText && !loading) && (
        <div className="result-panel">
          <div className="result-title">TRANSLATION SCRIPT</div>
          <div className="result-box">{translatedText}</div>
        </div>
      )}
    </div>
  );
}

export default App;


// ======================================================
// File: src\App.test.js
// ======================================================

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


// ======================================================
// File: src\index.css
// ======================================================

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


// ======================================================
// File: src\index.js
// ======================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


// ======================================================
// File: src\reportWebVitals.js
// ======================================================

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


// ======================================================
// File: src\setupTests.js
// ======================================================

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


